# 缓存系统

## 🎯 核心知识点

- 缓存策略与算法
- 分布式缓存设计
- 缓存一致性保证
- 缓存穿透、击穿、雪崩
- Redis集群架构
- 缓存预热与更新

## 📊 缓存架构层次

```mermaid
graph TD
    A[缓存架构] --> B[浏览器缓存]
    A --> C[CDN缓存]
    A --> D[反向代理缓存]
    A --> E[应用缓存]
    A --> F[数据库缓存]
    
    B --> B1[HTTP缓存]
    B --> B2[LocalStorage]
    B --> B3[SessionStorage]
    
    C --> C1[边缘节点]
    C --> C2[静态资源]
    C --> C3[动态内容]
    
    D --> D1[Nginx缓存]
    D --> D2[Varnish]
    D --> D3[Squid]
    
    E --> E1[进程内缓存]
    E --> E2[分布式缓存]
    E --> E3[数据库连接池]
    
    F --> F1[查询结果缓存]
    F --> F2[Buffer Pool]
    F --> F3[索引缓存]
```

## 💡 面试题目

### **初级** 缓存淘汰算法对比
**题目：** 介绍常见的缓存淘汰算法，并分析各自的优缺点和适用场景。

**答案要点：**

```mermaid
graph LR
    A[缓存淘汰算法] --> B[LRU最近最少使用]
    A --> C[LFU最不经常使用]
    A --> D[FIFO先进先出]
    A --> E[Random随机淘汰]
    A --> F[TTL时间过期]
    
    B --> B1[优点: 考虑时间局部性]
    B --> B2[缺点: 实现复杂度高]
    
    C --> C1[优点: 考虑访问频率]
    C --> C2[缺点: 新数据不友好]
    
    D --> D1[优点: 实现简单]
    D --> D2[缺点: 不考虑访问模式]
    
    E --> E1[优点: 实现最简单]
    E --> E2[缺点: 效果不可预测]
    
    F --> F1[优点: 内存可控]
    F --> F2[缺点: 需要设置合理TTL]
```

**算法实现复杂度对比：**

| 算法 | 时间复杂度 | 空间复杂度 | 实现难度 | 适用场景 |
|------|----------|----------|----------|----------|
| LRU | O(1) | O(n) | 中等 | 时间局部性强 |
| LFU | O(log n) | O(n) | 复杂 | 访问模式稳定 |
| FIFO | O(1) | O(1) | 简单 | 均匀访问模式 |
| Random | O(1) | O(1) | 最简单 | 随机访问模式 |

### **中级** 缓存一致性解决方案
**题目：** 在分布式系统中，如何解决缓存与数据库的数据一致性问题？请设计一个解决方案。

**答案要点：**

```mermaid
sequenceDiagram
    participant Client
    participant App
    participant Cache
    participant DB
    participant MQ
    
    Note over Client,MQ: 写入操作 - Cache Aside模式
    Client->>App: 写入请求
    App->>DB: 更新数据库
    DB->>App: 更新成功
    App->>Cache: 删除缓存
    App->>Client: 返回成功
    
    Note over Client,MQ: 异步更新模式
    Client->>App: 写入请求
    App->>DB: 更新数据库
    DB->>MQ: 发送更新事件
    MQ->>Cache: 异步更新缓存
    App->>Client: 返回成功
```

**一致性策略对比：**

```mermaid
graph TD
    A[缓存一致性策略] --> B[强一致性]
    A --> C[最终一致性]
    A --> D[弱一致性]
    
    B --> B1[同步更新]
    B --> B2[分布式锁]
    B --> B3[两阶段提交]
    
    C --> C1[异步更新]
    C --> C2[事件驱动]
    C --> C3[定时同步]
    
    D --> D1[允许短暂不一致]
    D --> D2[读写分离]
    D --> D3[降级处理]
```

### **高级** Redis集群设计
**题目：** 设计一个支持高可用、高性能的Redis集群架构，支持10万QPS的读写操作。

**答案要点：**

```mermaid
graph TB
    subgraph "客户端层"
        A[应用客户端] --> B[Redis客户端]
    end
    
    subgraph "代理层"
        B --> C[Twemproxy/Codis]
        C --> D[分片路由]
    end
    
    subgraph "Redis集群"
        D --> E[分片1<br/>Master-Slave]
        D --> F[分片2<br/>Master-Slave]
        D --> G[分片3<br/>Master-Slave]
        D --> H[分片4<br/>Master-Slave]
        
        E --> E1[Redis Master 1]
        E --> E2[Redis Slave 1]
        
        F --> F1[Redis Master 2]
        F --> F2[Redis Slave 2]
        
        G --> G1[Redis Master 3]
        G --> G2[Redis Slave 3]
        
        H --> H1[Redis Master 4]
        H --> H2[Redis Slave 4]
    end
    
    subgraph "监控层"
        I[Redis Sentinel]
        J[监控告警]
    end
    
    I --> E1
    I --> F1
    I --> G1
    I --> H1
```

**集群特性对比：**

| 方案 | 优点 | 缺点 | 适用场景 |
|------|------|------|----------|
| Redis Cluster | 原生支持、自动故障转移 | 某些命令限制 | 大规模部署 |
| Twemproxy | 轻量级、协议兼容 | 单点故障 | 中小规模 |
| Codis | 功能丰富、管理界面 | 架构复杂 | 企业级应用 |
| Redis Sentinel | 高可用保证 | 不支持分片 | 主从架构 |

## 🔧 缓存设计模式

### Cache-Aside模式

```mermaid
flowchart TD
    A[读取数据] --> B{缓存命中?}
    B -->|是| C[返回缓存数据]
    B -->|否| D[从数据库读取]
    D --> E[更新缓存]
    E --> F[返回数据]
    
    G[写入数据] --> H[更新数据库]
    H --> I[删除缓存]
    I --> J[返回结果]
```

### Write-Through模式

```mermaid
flowchart TD
    A[写入数据] --> B[更新缓存]
    B --> C[同步写入数据库]
    C --> D[返回结果]
    
    E[读取数据] --> F{缓存命中?}
    F -->|是| G[返回缓存数据]
    F -->|否| H[从数据库读取]
    H --> I[更新缓存]
    I --> J[返回数据]
```

### Write-Behind模式

```mermaid
flowchart TD
    A[写入数据] --> B[更新缓存]
    B --> C[返回结果]
    C --> D[异步写入数据库]
    
    E[读取数据] --> F{缓存命中?}
    F -->|是| G[返回缓存数据]
    F -->|否| H[从数据库读取]
    H --> I[更新缓存]
    I --> J[返回数据]
```

## 🛡️ 缓存问题解决方案

### 缓存穿透

```mermaid
graph TD
    A[缓存穿透] --> B[问题描述]
    A --> C[解决方案]
    
    B --> B1[查询不存在的数据]
    B --> B2[绕过缓存直击数据库]
    B --> B3[可能导致数据库压力]
    
    C --> C1[布隆过滤器]
    C --> C2[缓存空值]
    C --> C3[参数校验]
    
    C1 --> C11[预先加载所有key]
    C1 --> C12[快速判断key是否存在]
    
    C2 --> C21[设置较短TTL]
    C2 --> C22[避免重复查询]
    
    C3 --> C31[接口层校验]
    C3 --> C32[过滤无效请求]
```

### 缓存击穿

```mermaid
sequenceDiagram
    participant T1 as 线程1
    participant T2 as 线程2
    participant T3 as 线程3
    participant Cache
    participant Lock
    participant DB
    
    Note over T1,DB: 热点key过期瞬间
    T1->>Cache: 查询热点数据
    Cache-->>T1: 缓存过期
    T2->>Cache: 查询热点数据
    Cache-->>T2: 缓存过期
    T3->>Cache: 查询热点数据
    Cache-->>T3: 缓存过期
    
    T1->>Lock: 获取分布式锁
    Lock->>T1: 获取成功
    T2->>Lock: 获取分布式锁
    Lock-->>T2: 获取失败，等待
    
    T1->>DB: 查询数据库
    DB->>T1: 返回数据
    T1->>Cache: 更新缓存
    T1->>Lock: 释放锁
    
    T2->>Cache: 查询缓存
    Cache->>T2: 返回数据
```

### 缓存雪崩

```mermaid
graph TD
    A[缓存雪崩预防] --> B[过期时间分散]
    A --> C[多级缓存]
    A --> D[限流降级]
    A --> E[熔断机制]
    
    B --> B1[随机TTL]
    B --> B2[不同业务不同过期时间]
    
    C --> C1[本地缓存+分布式缓存]
    C --> C2[热点数据永不过期]
    
    D --> D1[接口限流]
    D --> D2[降级预案]
    
    E --> E1[失败率阈值]
    E --> E2[自动恢复机制]
```

## ⚡ 性能优化策略

### 缓存预热

```mermaid
flowchart TD
    A[缓存预热策略] --> B[全量预热]
    A --> C[增量预热]
    A --> D[懒加载预热]
    
    B --> B1[系统启动时加载]
    B --> B2[适用于数据量小的场景]
    
    C --> C1[根据访问模式预热]
    C --> C2[定时任务触发]
    
    D --> D1[访问时触发预热]
    D --> D2[异步加载相关数据]
```

### 缓存分层

```mermaid
graph TB
    A[用户请求] --> B[L1: 本地缓存]
    B --> C{L1命中?}
    C -->|是| D[返回结果]
    C -->|否| E[L2: 分布式缓存]
    E --> F{L2命中?}
    F -->|是| G[更新L1缓存]
    G --> H[返回结果]
    F -->|否| I[L3: 数据库]
    I --> J[更新L2缓存]
    J --> K[更新L1缓存]
    K --> L[返回结果]
```

## 📈 监控指标

### 缓存性能指标

```mermaid
graph TD
    A[缓存监控] --> B[命中率指标]
    A --> C[性能指标]
    A --> D[可用性指标]
    A --> E[容量指标]
    
    B --> B1[缓存命中率]
    B --> B2[缓存穿透率]
    B --> B3[热点数据分布]
    
    C --> C1[响应时间]
    C --> C2[QPS/TPS]
    C --> C3[并发连接数]
    
    D --> D1[服务可用性]
    D --> D2[故障恢复时间]
    D --> D3[主从延迟]
    
    E --> E1[内存使用率]
    E --> E2[网络带宽]
    E --> E3[磁盘IO]
```

### 告警策略

| 指标 | 告警阈值 | 级别 | 处理措施 |
|------|----------|------|----------|
| 缓存命中率 | <80% | 警告 | 检查缓存策略 |
| 内存使用率 | >85% | 严重 | 扩容或清理 |
| 响应时间 | >100ms | 警告 | 性能调优 |
| 服务可用性 | <99% | 严重 | 故障切换 |

## 🔍 故障排查

### 常见问题诊断

```mermaid
flowchart TD
    A[缓存问题] --> B{性能问题}
    A --> C{数据问题}
    A --> D{可用性问题}
    
    B --> B1[检查命中率]
    B --> B2[检查响应时间]
    B --> B3[检查网络延迟]
    
    C --> C1[检查数据一致性]
    C --> C2[检查TTL设置]
    C --> C3[检查更新策略]
    
    D --> D1[检查服务状态]
    D --> D2[检查网络连通性]
    D --> D3[检查资源使用率]
```

## 💡 面试要点总结

### 设计考虑因素
1. **业务特征**：读写比例、数据热度、一致性要求
2. **性能需求**：延迟要求、吞吐量目标、并发量
3. **可靠性要求**：可用性目标、容错能力、恢复时间
4. **成本控制**：硬件成本、运维成本、开发成本

### 权衡取舍
- **一致性 vs 性能**：强一致性 vs 高性能访问
- **成本 vs 效果**：缓存命中率 vs 存储成本
- **复杂性 vs 可维护性**：功能丰富 vs 系统简单
- **可用性 vs 一致性**：CAP理论在缓存中的应用

### 最佳实践
1. **合理设置TTL**：避免缓存雪崩和数据过期
2. **监控关键指标**：命中率、响应时间、错误率
3. **预案准备**：缓存失效时的降级策略
4. **定期优化**：根据访问模式调整缓存策略

## 🔗 相关链接

- [← 返回系统设计主页](./README.md)
- [数据库设计](./database-design.md)
- [分布式系统](./distributed-systems.md)
- [负载均衡](./load-balancing.md)

---

*缓存是提升系统性能的重要手段，但需要在一致性、性能和复杂性之间找到平衡* ⚡ 